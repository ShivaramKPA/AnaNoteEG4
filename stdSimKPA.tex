%This is the first/leading file on the whole ``Data_Analysis Chapter
%Created by kp on Sep 11, 2013

\hspace{0.5cm}


\section{``Standard'' simulation}
\label{stand}

The simulation process consists of mainly three parts - generating inclusive events similar to the ones %as
produced in the double polarization scattering process, simulating the CLAS detector response, and finally the event reconstruction from %out of 
the simulated detector signals.

The first part is accomplished by using a program that is made by combining the essential elements of an updated version of the ``RCSLACPOL'' program (for cross section generation) and some parts of the ``STEG'' (SimplesT Event Generator) event generator (see sections \ref{rcslacpol} and \ref{evGen}). The second part is done by two standard CLAS software packages running in succession - ``GSIM'' and ``GPP''(see sections \ref{gsim} and \ref{gpp}). And, finally, the %another 
standard CLAS package ``RECSIS'' is used to reconstruct the events in the same way as for the real CLAS data.


\subsection{RCSLACPOL}
\label{rcslacpol}
The simulation for the standard model cross sections %inputs 
proceeds as follows. We use the code ``RCSLACPOL'' \cite{PolNit:ref} %(see Sec.~\ref{evGen}) 
that can generate polarized and unpolarized cross sections (both Born and radiated) based on the %standard 
approach by Shumeiko and Kuchto \cite{Kuchto:ref} as well as Mo and Tsai \cite{MoTsai:ref}, including external radiation in the target. This code has been extensively tested and used for the analysis of SLAC experiments E142, E143, E154, E155 and E155x %\textcolor{red}{Reference?}
as well as Jefferson Lab experiments like EG1a and EG1b. %\textcolor{red}{Reference?}
It has been updated with the most recent models on polarized and unpolarized structure functions ($F_1, F_2, A_1$ and $A_2$) \cite{Bosted:2007xd,PolNit:ref,EG1bProt,EG1bDeut} %\textcolor{red}{Reference?}
and an implementation of the folding algorithm developed by W. Melnitchouk and Y. Kahn \cite{KahnEtal} for structure functions of the deuteron. The models have been fitted to and tested with data from EG1b as well as world data on both $A_1$ and $A_2$ over a wide range of $Q^2$ and $W$, including the resonance region and the DIS region.

%\textbf{\textcolor{red}{For Radiative corrections refer to a more detailed separate section on the topic.}}\\ %\\%\newline

For EG4, we have combined the %code of 
``RCSLACPOL'' code with that of the ``STEG'' event generator. This generator uses a grid of (radiated) cross sections generated by our modified version of RCSLACPOL to generate events that are distributed according to these cross sections %tables 
(i.e., the number of events generated in a given bin is proportional to the cross section integrated over this bin).


\subsection{Event Generator}
\label{evGen}

%This is an event generator that was inherited from INFN, in Genova, Italy. As far as I know, it's primary author is M. Osipenko and a couple of people have contributed to some of the codes/routines in it. So, far I can see the names of P. Bosted, G. Gavalian and Cole Smith in some of the files. I got the codes from Vadim Drozdov who was a postdoctoral associate in Genova. This generator essentially cosists of three executables steg_tab_Linux, read_map_Linux and steg_Linux made out of compiling codes in three different directories generate_map, read_map and work (which I have renamed as work_kp2). The ultimate output from the generator is a bos and hbook file 'steg.bos' and steg.hbook' which contains information of a certain number of electrons distributed in a predefined way which tries to simulate electrons as seen by CLAS detector right after they come out of the target after the beam-target interaction % %http://wwwold.jlab.org/Hall-B/secure/eg4/adhikari/Simulations/mod_osip_bost_4kpDoc/steg.html

%Important points/changes: 
The concept and some part of the generator skeleton was inherited from the STEG (SimplesT Event Generator) %\textcolor{red}{Reference?}
 program obtained from INFN, in Genova, Italy. The old event sampling part (which made the program run extremely slow) of the code was replaced by a new one developed by myself which made the event generation process much faster. %a thing of a minute or two). %And the 
The cross section calculating part was replaced by codes from an updated version of RCSLACPOL (see Sec.~\ref{rcslacpol}).


%SEK analysis note for EG4: For EG4, we have ``married'' this code with the event generator ``STEG'' developed by the Genova group. This generator uses a grid of (radiated) cross sections generated by our modified version of RCSLACPOL to generate events that are distributed according to these tables (i.e., the number of events generated in a given bin is proportional to the cross section integrated over this bin). For our application, we need to generate two such tables: For all bins in which the integrated cross section $\Delta \sigma \ge 0$, we fill the first table which is therefore positive-definite. For all bins in which this cross section is below $0$, we fill a second table, but with the absolute (i.e. negative) value of this cross section. We integrate both tables over all bins that will be used for event generation and then proceed to generate a number of electrons that is proportional to this integrated cross section for each table. (In principle, we can define a suitable number ${\mathcal L}_s$ - the simulated luminosity - such that the number of events generated in each bin and for each table is simply ${\mathcal L}_s \cdot |\Delta \sigma|$.) These events are then fed through the complete chain of GSIM, GPP and RECSIS (where the latter processes them the same way as real data). Finally, all applicable cuts and corrections are applied. There are some important details on how to handle detectors (like the CC and, to a lesser extent, the EC) which are known to be imperfectly simulated in GSIM (if at all), and how to correct for further inefficiencies (for instance luminosity-dependent tracking inefficiencies) - the simulated data have to be corrected for those ``by hand''. The details will be described elsewhere. We also have to account for pions and other background mis-identified as electrons and for electrons from pair-symmetric decays that are present in the data (as part of the term $Bg$ in Eq.~\ref{Delndef}) but not in the simulation. Finally, we have to account for the polarized background by adjusting the simulated  or experimental data


The generator works in two steps. First, it generates two two-dimensional maps or tables of radiated inclusive polarized cross differences %sections 
(for the scattering of polarized electrons from a longitudinally polarized deuteron target, by using RCSLACPOL) in various kinematic bins encompassing the kinematic region covered by EG4 data. 
%One of the two maps (``positive map'') is made by keeping only the positive definite values of the cross section differences $\Delta \sigma \ge 0$ in the kinematic bins. In this case, the bins that had negative values of $\Delta \sigma$ are assigned zero values. The other map (``negative map'') is now made by keeping only the absolute values of the negative cross-section differences $\Delta \sigma$, which means, all the other bins that didn't have negative values for $\Delta \sigma$ get 0 values in this table. %11/26/13
These cross section maps (and the corresponding events later on) were generated in the following angular and momentum ranges: 5.0-45.0 degrees for \th, 250.0-325.0 degrees for \ph (to ensure the CLAS 6th sector is completely covered) and (0.2,$E_{beam}$) GeV for the momenta, where the beam energy $E_{beam}$ took values of 1.337 and 1.993 GeV, corresponding to the two \nd3 data sets of EG4. 
%\footnote{We generated cross section maps and the events in the following angular and momentum ranges: (5.0,45.0) degrees for \th, (250.0,325.0) degrees for \ph (to ensure the CLAS 6th sector is completely covered) and (0.2,$E_{beam}$) GeV for the momenta, where, the beam energy $E_{beam}$ took values of 1.337 and 1.993 GeV, corresponding to the two \nd3 data sets of EG4. Likewise, these events are given the vertex coordinates that are uniformly distributed over the volume of a 1 cm long cylinder with radius 0.01 cm around the beam line - with the center of this volume being at the EG4 target position of (0,0,-100.93 cm).}.
In our case, the map was created by dividing the kinematic phase space into a grid of small rectangles %squares/rectangles 
and then calculating the differential cross-section at the geometric center of each of those squares (such as ABCD in Fig.~\ref{CSgrid}).
 For our application, we need to generate two such maps (because of the impossibility %difficulty/complexity 
of generating events according to negative cross-sections) and run the program twice - once corresponding to positive %polarization 
$\Delta \sigma$ and the next for the negative one. For all bins in which the integrated cross section $\Delta \sigma \ge 0$, we fill the first table (``positive map'') which is therefore positive-definite. For all bins in which this cross section is below $0$, we fill a second table (``negative map'') , but with the absolute (i.e. negative) value of this cross section. %We integrate both tables over all bins that will be used for event generation and then proceed to generate a number of electrons that is proportional to this integrated cross section for each table. (In principle, we can define a suitable number ${\mathcal L}_s$ - the simulated luminosity - such that the number of events generated in each bin and for each table is simply ${\mathcal L}_s \cdot |\Delta \sigma|$.)

%The first program 'steg_tab_Linux' calculates, for a given beam and torus condition, the cross-section at each of the grid points (such as A, B, C, D etc. in Fig 1) in the kinematic phase space (# of bins and the size of the kinematic region is predefined using include and input files binning.inc and steg_tab.inp) and records them in a data file cs_max.dat (will have (N_th+1)*(N_p+1) numbers in a single column where N_th and N_p are the # of bins in theta and p respectively. The program also calculates the total cross-section (adding the values from all those grid points together) and records that in the output file cs_int.dat (will have only one number).
%The second program 'read_map_Linux' reads in all the cross-section values for various grid-points from the cs_max.dat file (created by the 1st program) and selects the maximum out of the four values from the four corners of each bin and selects that as the cross-section for the given bin. (So, for the bin represented by the square ABCD, the maximu of the four values from the four corners A, B, C and D will be the one that goes for that bin). All these maxima are now recorded in a new data file cs_max_new.dat. This program also evaluates the acceptance for each of the bins using a routine available in acceptance_el.f. The cross-sections (one per bin, not all four, only the maximum one) and the acceptances for all the bins are added together and recorded as the last numbers in each of the two files.

In the second stage, events are thrown %sampled/thrown 
according to the cross section maps produced in the first stage. %Likewise, these 
The events are given vertex coordinates that are uniformly distributed over the volume of a 1 cm long cylinder with radius 0.01 cm around the beam line - with the center of this volume being at the EG4 target position of (0,0,-100.93 cm). Nearly equal numbers of events are generated for each %polarization,
 sign of $\Delta \sigma$ they are finally normalized according to their total cross sections (integrals %sums 
of the corresponding maps). %tables/maps). 


%The third program takes in idential input parameters, reads in the output data from the second program for the maximum cross-section and acceptance map, creates a certain number (= nstory: a number to be fixed in the input file steg.inp) of events/electrons distributed over the given kinematic space with their population reflective of the cross-section (and acceptance) map and writes them onto the output files steg.bos (and steg.hbook). It seems to me that the importance sampling (to have distribution in sync with the cross-section map) is done by calling the subroutine 'sum_uni_distr(...)' which is in the file 'sum_uni_distr.f'. 

The kinematic and other information (positions, momenta, charge) of these generated %events/electrons
events %\footnote{in the inclusive process a scattered electron is what amounts to an event, so events and electrons will be used interchangeably} 
are recorded and saved in the BOS format\footnote{Existing versions of GSIM, GPP and RECSIS accept only BOS format for input files.} output files which organizes data into banks. In our case, HEAD, MCEV, MCTK, and MCVX banks are used for the generator output. The generator is also capable of producing output in the hbook format which makes it possible to study the Monte Carlo data using PAW (or ROOT because the h2root program easily converts ``hbook'' files into ``root'' files).

%\textbf{\textcolor{red}{To be elaborated or improved.}}
\begin{figure}[htpb] %ht, htpb (p - float, b = bottom, h=? t = top)
\centering
%  \leavevmode \includegraphics[width=0.6\textwidth]{chap4simul/Figures/kineGrid_steg.jpg} 
  %\leavevmode \includegraphics[width=0.6\textwidth]{chap4simul/Figures/kineGrid_steg.eps} 
  \leavevmode \includegraphics[width=0.6\textwidth]{figuresEG4/FigSim/kineGrid_steg.png} 
  \caption[A section of the kinematics grid]{Corners of a typical bin highlighted in the kinematic space covered by the event generator.}
  \label{CSgrid}  %http://wwwold.jlab.org/Hall-B/secure/eg4/adhikari/Simulations/mod_osip_bost_4kpDoc/steg.html
\end{figure}

\begin{comment}
adhikari@ifarm1101> pwd
/w/hallb/claseg4/adhikari/RCSLACPOL/JobSubs/TestExe
adhikari@ifarm1101> m ../stegRcInpFor2_npEb8ms2hSqNw_Eb8F10T0pMax0_000.inp
1.993
-2250
0.01
0.0
0.0
1.0
-100.93
5.000
45.000
250.0
325.0
0.2
1.993
N
N
70000
cs_map.dat
acc_map.dat
steg.bos
2
adhikari@ifarm1101> m ../stegRcInpFor2_npEb7ms2hSqNw_Eb7F30T13pMax0_000.inp 
1.337
-1500
0.01
0.0
0.0
1.0
-100.93
5.000
45.000
250.0
325.0
0.2
1.337
N
N
70000
cs_map.dat
acc_map.dat
steg.bos
2
===============
c Extracting vertex position
      vert_r=rran()*r_beam         ! Vertex radius  kp: 9/18/13: (the third parameter=0.01 in above input file which comes after the torus current)
c+ accordiong e6a target radius=3.5-6 mm
c+ generating outside target volume (on a cylinder surface
c+ but Gagik implemented 1cm radius
c      vert_r = 1.
      vert_phi=rran()*2.e0*pi       ! Vertex phi
      vert_x=x_beam+vert_r*cos(vert_phi)
      vert_y=y_beam+vert_r*sin(vert_phi)
      vert_z=t_offset+(rran()-0.5e0)*t_length  ! Target lenght + offset
======
Looking at the latter parts of steg*.f that was used in the generator, four banks HEAD, MCEV, MCTK & MCVX were used
to produce the BOS files
      CALL BOS(IWW,Nbcs)
      CALL BKFMT('HEAD','I')
      CALL BKFMT('MCEV','I')
      CALL BKFMT('MCTK','(6F,5I)')
      CALL BKFMT('MCVX','(4F,I)')     ! MC vertex parameters
c Booking BOS bank
c general banks
      iHEAD = NBANK('HEAD',0,8,1)  ! BOS HEADER
      IWW(iHEAD+1)=2                ! Version Number
      IWW(iHEAD+2)=RUN              ! Run Number
      IWW(iHEAD+3)=MEVT             ! Event Number
      IWW(iHEAD+4)=0                ! Event Time
      IWW(iHEAD+5)=-1               ! Event Type
      IWW(iHEAD+6)=0                ! ROC: sync status is 0-OK, > 0bit pattern of offending ROC's
      IWW(iHEAD+7)=7                ! Event Classification from DAQ: 1-15 Physics Events
      IWW(iHEAD+8)=1                ! Level 1 Trigger Latch Word (16 bits)
      NR=MEVT
      iMCEV = NBANK('MCEV',0,2,1)
      IWW(iMCEV+1) = int(rran()*100000)  ! first geant random number seed for event
      IWW(iMCEV+2) = int(rran()*100000)  ! second seed
      iMCVX = NBANK('MCVX',0,5,1)
      rw(iMCVX+1) = vert_x         ! x of vertex
      rw(iMCVX+2) = vert_y         ! y
      rw(iMCVX+3) = vert_z         ! z
c      rw(iMCVX+4) = 0e0           ! secs of flight
      rw(iMCVX+4) = 1.e-9*(vert_z-t_offset)/c      ! secs of flight
      IWW(iMCVX+5) = 0              ! vertex flag
c Particle bank
      IMCTK = NBANK('MCTK',0,11,2)
c Electron
      ipart = 11*(1-1)
      rw(imctk+ipart+1)=sin(theta_el)*cos(phi_el) ! x dir cosine at track origin
      rw(imctk+ipart+2)=sin(theta_el)*sin(phi_el) ! y dir cosine
      rw(imctk+ipart+3)=cos(theta_el)             ! z dir cosine
      rw(imctk+ipart+4)=p_el                      ! momentum
      rw(imctk+ipart+5)=me                        ! mass
      rw(imctk+ipart+6)=-1.e0                     ! charge
      IWW(imctk+ipart+7)=11                        ! track Particle Data Group id
      IWW(imctk+ipart+8)=0                         ! track flag
      IWW(imctk+ipart+9)=1                         ! beginning vertex number
      IWW(imctk+ipart+10)=0                        ! ending vertex number
      IWW(imctk+ipart+11)=0                        ! parent track
c Increment event numer
\end{comment}





\subsection{GSIM - CLAS Detector Simulation} 
\label{gsim}
The Monte Carlo events thus generated are next fed into GSIM - the CLAS Monte Carlo simulation program using GEANT 3.21 libraries from CERN \cite{gsimMH_wb}. It %. -which 
simulates the CLAS detector response by implementing a complete model of the detector as well as the propagation of particles through different materials including all physics processes, such as multiple scattering, energy loss, pair production, and nuclear interactions. The program takes the input event particles and then, based on their types, momenta and positions, %then 
``swims'' (traces) them through all %a large number of detector 
volumes of different materials that are defined using various library routines and the detector parameters. Charged particles are also subjected to the effects of the torus and target magnetic fields of the same strength as in the actual experiment (for this the same field maps are used as in the track reconstruction process using RECSIS). All the ingredients of the program (field maps, active detection volumes, passive volumes of detector support structures etc) are modeled as accurately as possible with the help of engineering designs and actual detector measurements. Special subroutines corresponding to various active parts of the detector produce outputs resembling the real detector signals which can then be reconstructed and analyzed just as the real experimental data \cite{clasBrooks}%pg 31 
\cite{bDey_th}. %pg 84
GSIM is configured to match with the conditions of a given experiment by giving it proper values of input parameters via a command line input file which contains various ``ffread cards'' some of which are listed in table-\ref{tab:ffread} along with their values that were used in our simulation.
%thKlimenko: Data Simln pg 86/105, Detector simulation 91/109


%\input{chap4simul/ffreadCards.tex}  %Moved to separate file (SEK suggestion for putting it in appendix, may be worthwile)


\subsection{GSIM POST PROCESSOR (GPP)} 
 \label{gpp}
The GSIM output is next passed onto GPP - another standard %important 
CLAS software package - to process the simulated data further so that the detector response is accounted for more accurately. This package improves the response by smearing the detector signals and removing them if there are dead regions (determined by querying %looking into 
a data base which in turn is made by looking at the raw data of the experiment).
% Look at A. Klimenko's thesis (viewer page 109) (found much better than B. Dey's (page 85)
% Maurizio Ungaru prepared & set up the database for us at the request of M. Ripani

%\begin{comment}  %enable the comment block to disable the following ``red'' comments
%\textbf{\textcolor{red}{Comment: Bring in the file (or some stuff from there) that I wrote on my work on DC-smearing. I may need to shorten the stuff by moving most of the part (describing the work that I did) to either an Appendix or to some separate analysis note. I may give a brief note on how I did that \& only list the numbers that I decided. In addition pay attention to smoothening the logical flow in the introductory part. Avoid redundancy of the statements.}}
%\end{comment}
%\textbf{\textcolor{red}{Heavy editing needs to be done here (old write-up).}}

%\input{chap4simul/dcSmear.tex}
%%%%%%%%%\input{dcSmear.tex}    % Disabled



%\subsection{RECSIS - Event Reconstruction}
%\label{recsis}
%\textbf{\textcolor{red}{Comment: Similar discussion on RECSIS may come elsewhere too, because RECSIS is used in the experimental data reconstruction too, so the section here may simply refer/cite that section rather than re-inventing the wheel.}}\\ %\\%\newline
%\textbf{Elaborate more on corrections.}
% Zixie thes: pg71, Nevzat: pg 111, 

%These GPP output that has the detector signals in response to the Monte Carlo events are then fed through  RECSIS (which processes them the same way as real data) to reconstruct the passed events.





